<div dir="rtl">

# آزمایش اول آز مهندسی نرم‌افزار

## سیدمحمدصادق طبائیان - 98105868

## عبدالصمد حقیری - 98105727



مراحل ساخت مخزن و اولین کامیت‌ها در شکل زیر قابل مشاهده است.

<img src="./init.JPG" width="350px">

ایجاد قانون جلوگیری از کامیت مستقیم به شاخه‌ی اصلی به شکل زیر است. (البته این قانون تا زمان ایجاد شاخه‌ها تنظیم نشد.)

<img src="./branchProtection.JPG" width="350px">

پرسش ۱: دستور git init یک مخزن (repo) جدید ایجاد می‌کند. این دستور، یک پوشه‌ی .git در مسیر فعلی ایجاد می‌کند که تمام متادیتای مورد نیاز گیت برای پروژه را در خود نگه می‌دارد. این متادیتا شامل پوشه‌هایی برای فایل‌های مرجع، قالب و آبجکت‌های گیت است. به علاوه یک فایل head که به کامیت checkout اشاره می‌کند. 

پرسش ۲: اتمیک بودن یعنی تشکیل یک جزء غیر قابل تقلیل در یک سیستم بزرگ‌تر. مثلا کامیت اتمیک یعنی انقدر کامیت را کوچک کنیم تا به کوچک‌ترین کامیت معنی‌دار برسد. نه اینکه یک کامیت بزنیم که در آن چند تغییر با هم اتفاق افتاده است. PR اتمیک هم یعنی PR ای که کوچک‌ترین و غیرقابل تقلیل‌ترین PR معنادار ممکن باشد. این کار تعداد PR ها را بیشتر می‌کند اما هر PR نشان‌دهنده‌ی یک کار مشخص و کوچک است.
اتمیک بودن باعث می‌شود برای بازبینی و پیداکردن باگ، کار راحت‌تری داشته باشیم.

پرسش ۳: زمانی که می‌خواهیم کامیت‌ها و فایل‌ها را از یک مخزن remote در مخزن محلی خودمان دانلود کنیم، از دستورهای git fetch و git pull استفاده می‌کنم.
با git fetch، محتوای remote دانلود می‌شود اما وضعیت کاری محلی آپدیت نمی‌شود. اما git pull، درواقع ترکیب دو دستور git fetch و git merge است. ابتدا یک git fetch را به شاخه محلی که head به آن اشاره می‌کند اجرا می‌کند. پس از دانلود محتوا، git merge اجرا می‌شود و یک کامیت جدید برای merge ایجاد می‌شود و head آپدیت می‌شود و به کامیت جدید اشاره می‌کند.
Git merge و git rebase هر دو برای یکپارچه‌سازی و ادغام تغییرات از یک شاخه به شاخه دیگر طراحی شده‌اند اما به روش‌های مختلفی این کار را انجام می‌دهند.
در merge، محتوای شاخه مبدا را با شاخه مقصد یکپارچه می‌کنیم. در این فرایند، فقط شاخه مقصد تغییر می‌کند و سابقه شاخه مبدا دست نخورده باقی می‌ماند.
در rebase، همه تغییرات 	شاخه مبدا را از شروع آخرین کامیت شاخه مقصد اضافه می‌کند. این روش بر خلاف merge، باعث از بین رفتن سابقه تغییرات می‌شود. زیرا کل کار را از یک شاخه به شاخه دیگر منتقل می‌کند.
پس merge، تاریخچه را حفظ می‌کند اما rebase آن را rewrite می‌کند. از طرفی از طریق rebase، می‌توان کامیت‌های نامطلوب را حذف کرد، پیام یک کامیت را ویرایش کرد و خلاصه تاریخچه کامیت را تغییر داد.

</div>

